// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// Further information: https://aka.ms/midi
// ============================================================================

// Windows MIDI Services sample code
// 
// Note: This sample uses all explicit types rather than "auto" so that it is 
// clear what types are being used when viewed online or in something other than
// an IDE with intellisense or equivalent. Other examples use "auto" which also
// works just fine in your own code. (the only exception in this example is the 
// event handler which remains "auto")


#include <iostream>

// files in the winrt folder have been auto-generated by C++/WinRT at compile time. If
// you need to use the versions packaged with the SDK, use the ones in /build/native/include/winmidi/winrt
#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Foundation.Collections.h>

#include <winrt/Microsoft.Windows.Devices.Midi2.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Diagnostics.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Messages.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.ClientPlugins.h>

using namespace winrt::Microsoft::Windows::Devices::Midi2;                  // SDK Core
using namespace winrt::Microsoft::Windows::Devices::Midi2::Diagnostics;     // For diagnostics loopback endpoints
using namespace winrt::Microsoft::Windows::Devices::Midi2::Messages;        // For message utilities and strong types
using namespace winrt::Microsoft::Windows::Devices::Midi2::ClientPlugins;   // For the built-in listeners

// where you find types like IAsyncOperation, IInspectable, etc.
namespace foundation = winrt::Windows::Foundation;

// This include file has a wrapper for the bootstrapper code. You are welcome to
// use the .hpp as-is, or work the functionality into your code in whatever way
// makes the most sense for your application.
// 
// The namespace defined in the .hpp is not a WinRT namespace, just a regular C++ namespace
#include "winmidi/init/Microsoft.Windows.Devices.Midi2.Initialization.hpp"
namespace init = Microsoft::Windows::Devices::Midi2::Initialization;

int main()
{
    // initialize the thread before calling the bootstrapper or any WinRT code.
    winrt::init_apartment(winrt::apartment_type::multi_threaded);

    // this is the initializer in the bootstrapper hpp file
    std::shared_ptr<init::MidiDesktopAppSdkInitializer> initializer = std::make_shared<init::MidiDesktopAppSdkInitializer>();

    // you can, of course, use guard macros instead of this check
    if (initializer != nullptr)
    {
        if (!initializer->InitializeSdkRuntime())
        {
            std::cout << "Could not initialize SDK runtime" << std::endl;
            std::wcout << "Install the latest SDK runtime installer from " << initializer->LatestMidiAppSdkDownloadUrl << std::endl;
            return 1;
        }

        if (!initializer->EnsureServiceAvailable())
        {
            std::cout << "Could not demand-start the MIDI service" << std::endl;
            return 1;
        }
    }
    else
    {
        // This shouldn't happen, but good to guard
        std::cout << "Unable to create initializer" << std::endl;
        return 1;
    }

    // create the MIDI session, giving us access to Windows MIDI Services. An app may open 
    // more than one session. If so, the session name should be meaningful to the user, like
    // the name of a browser tab, or a project.

    std::cout << std::endl << "Creating session..." << std::endl;

    MidiSession session = MidiSession::Create(L"Sample Session");

    winrt::hstring endpointBId = MidiDiagnostics::DiagnosticsLoopbackBEndpointDeviceId();

    MidiEndpointConnection receiveEndpoint = session.CreateEndpointConnection(endpointBId);
    std::cout << "Connected to receiving endpoint: " << winrt::to_string(endpointBId) << std::endl;

    // Wire up an event handler to receive the message. There is a single event handler type, but the
    // MidiMessageReceivedEventArgs class provides the different ways to access the data
    // Your event handlers should return quickly as they are called synchronously.
    // 
    // Multiple connections (or more correctly, MessageReceived event sources) can share the same
    // event handler function, which does not have to be a lambda.
    auto MessageReceivedHandler = [&](IMidiMessageReceivedEventSource const& sender, MidiMessageReceivedEventArgs const& args)
        {
            IMidiUniversalPacket ump = args.GetMessagePacket();

            MidiGroupEndpointListener plugin{ nullptr };
            if (sender.try_as<MidiGroupEndpointListener>(plugin))
            {
                // this requires Customer Preview 3 or later. In Customer Preview 2, the implementation type was always the parent MidiEndpointConnection
                std::cout << "From: " << winrt::to_string(plugin.PluginName()) << std::endl;
            }
            
            // display message info. All UMP types which implement IMidiUniversalPacket also
            // implement the IStringable interface, enabling ToString()
            std::cout << winrt::to_string(ump.as<winrt::Windows::Foundation::IStringable>().ToString()) << std::endl;
        };


    // listeners are less expensive than opening separate connections to the same endpoint
    MidiGroupEndpointListener groupListener0;
    groupListener0.IncludedGroups().Append(MidiGroup(static_cast<uint8_t>(0)));  // casting is required due to built-in WinRT constructor that takes a pointer
    groupListener0.PreventCallingFurtherListeners(false);
    groupListener0.PreventFiringMainMessageReceivedEvent(true);
    groupListener0.PluginName(L"Group 1 Listener");                 // you can also set the tag to something meaningful that can be boxed to IInspectable 
    groupListener0.IsEnabled(true);

    MidiGroupEndpointListener groupListener1;
    groupListener1.IncludedGroups().Append(MidiGroup(1));
    groupListener1.PreventCallingFurtherListeners(false);
    groupListener1.PreventFiringMainMessageReceivedEvent(true);
    groupListener1.PluginName(L"Group 2 Listener");
    groupListener1.IsEnabled(true);

    MidiGroupEndpointListener groupListener2;
    groupListener2.IncludedGroups().Append(MidiGroup(2));
    groupListener2.PreventCallingFurtherListeners(false);
    groupListener2.PreventFiringMainMessageReceivedEvent(true);
    groupListener2.PluginName(L"Group 3 Listener");
    groupListener2.IsEnabled(true);

    // this "all other" endpoint is optional. Here just to demonstrate getting data from more than one group
    MidiGroupEndpointListener groupListenerAllOthers;

    for (uint8_t groupIndex = 3; groupIndex < 16; groupIndex++)
    {
        groupListenerAllOthers.IncludedGroups().Append(MidiGroup(groupIndex));
    }
    groupListenerAllOthers.PreventCallingFurtherListeners(false);           // this could be set to true as there are no other listeners
    groupListenerAllOthers.PreventFiringMainMessageReceivedEvent(true);
    groupListenerAllOthers.PluginName(L"All others");
    groupListenerAllOthers.IsEnabled(true);

    // we wire up event handlers only for the listeners
    // the returned token is used to deregister the event later.

    std::map<winrt::guid, winrt::event_token> revokeTokens{};

    revokeTokens[groupListener0.PluginId()] = groupListener0.MessageReceived(MessageReceivedHandler);
    revokeTokens[groupListener1.PluginId()] = groupListener1.MessageReceived(MessageReceivedHandler);
    revokeTokens[groupListener2.PluginId()] = groupListener2.MessageReceived(MessageReceivedHandler);
    revokeTokens[groupListenerAllOthers.PluginId()] = groupListenerAllOthers.MessageReceived(MessageReceivedHandler);

    // add the message processing plugins before opening the connection, so the event handlers are ready
    receiveEndpoint.AddMessageProcessingPlugin(groupListener0);
    receiveEndpoint.AddMessageProcessingPlugin(groupListener1);
    receiveEndpoint.AddMessageProcessingPlugin(groupListener2);
    receiveEndpoint.AddMessageProcessingPlugin(groupListenerAllOthers);

    std::cout << std::endl << "Opening endpoint connection..." << std::endl;

    if (receiveEndpoint.Open())
    {
        std::cout << std::endl << "Connection opened." << std::endl;
        std::cout << std::endl << "Send messages to this endpoint from an external program or device and hit enter when done." << std::endl;
        system("pause");
    }
    else
    {
        std::cout << std::endl << "Unable to open endpoint connection." << std::endl;
    }

    // Cleanup code follows =============================================================================

    // deregister event handlers
    std::cout << std::endl << "Deregistering event handlers..." << std::endl;
    for (auto const& plugin : receiveEndpoint.MessageProcessingPlugins())
    {
        if (auto const& iter = revokeTokens.find(plugin.PluginId()); iter != revokeTokens.end())
        {
            // event revoke tokens have a bool op that evals to true when the token is valid
            if (iter->second)
            {
                // we know that all the plugins are of this type, so this is safe here
                plugin.as<IMidiMessageReceivedEventSource>().MessageReceived(iter->second);
            }
        }
    }

    // you could also remove the endpoint message processing plugins here, but it is not necessary
    // only cleaning up the event handlers is needed

    std::cout << "Disconnecting UMP Endpoint Connection..." << std::endl;

    // if you close the session, this automatically happens. But keeping here to show how to manually handle closing connections
    session.DisconnectEndpointConnection(receiveEndpoint.ConnectionId());

    // close the session, detaching all Windows MIDI Services resources and closing all connections
    // You can also disconnect individual Endpoint Connections when you are done with them, as we did above
    session.Close();

    // ensure we release all the WinRT and COM objects before uninitializing COM
    // otherwise, you can crash when closing down the apartment. You could just put them all in 
    // a sub-scope which closes before the uninit_apartment call, or you can set them to nullptr.
    groupListener0 = nullptr;
    groupListener1 = nullptr;
    groupListener2 = nullptr;
    groupListenerAllOthers = nullptr;
    receiveEndpoint = nullptr;
    session = nullptr;

    // clean up the SDK WinRT redirection
    std::cout << "Cleaning up SDK..." << std::endl;
    if (initializer != nullptr)
    {
        initializer->ShutdownSdkRuntime();
        initializer.reset();
    }

    std::cout << "Cleaning up WinRT / COM apartment..." << std::endl;
    winrt::uninit_apartment();

}
