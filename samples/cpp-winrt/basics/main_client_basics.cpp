// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// Further information: https://aka.ms/midi
// ============================================================================

// Windows MIDI Services sample code
// 
// Note: This sample uses all explicit types rather than "auto" so that it is 
// clear what types are being used when viewed online or in something other than
// an IDE with intellisense or equivalent. Other examples use "auto" which also
// works just fine in your own code. (the only exception in this example is the 
// event handler which remains "auto")


#include <iostream>

// files in the winrt folder have been auto-generated by C++/WinRT at compile time. If
// you need to use the versions packaged with the SDK, use the ones in /build/native/include/winmidi/winrt
#include <winrt/Windows.Foundation.h>

#include <winrt/Microsoft.Windows.Devices.Midi2.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Diagnostics.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Messages.h>

using namespace winrt::Microsoft::Windows::Devices::Midi2;                  // SDK Core
using namespace winrt::Microsoft::Windows::Devices::Midi2::Diagnostics;     // For diagnostics loopback endpoints
using namespace winrt::Microsoft::Windows::Devices::Midi2::Messages;        // For message utilities and strong types

// where you find types like IAsyncOperation, IInspectable, etc.
namespace foundation = winrt::Windows::Foundation;

// This include file has a wrapper for the bootstrapper code. You are welcome to
// use the .hpp as-is, or work the functionality into your code in whatever way
// makes the most sense for your application.
// 
// The namespace defined in the .hpp is not a WinRT namespace, just a regular C++ namespace
#include "winmidi/init/Microsoft.Windows.Devices.Midi2.Initialization.hpp"
namespace init = Microsoft::Windows::Devices::Midi2::Initialization;

int main()
{
    // initialize the thread before calling the bootstrapper or any WinRT code. You may also
    // be able to leave this out and call RoInitialize() or CoInitializeEx() before creating
    // the initializer.
    //winrt::init_apartment(winrt::apartment_type::single_threaded);

    // MTA by default
    winrt::init_apartment();

    // this is the initializer in the bootstrapper hpp file
    std::shared_ptr<init::MidiDesktopAppSdkInitializer> initializer = std::make_shared<init::MidiDesktopAppSdkInitializer>();

    // you can, of course, use guard macros instead of this check
    if (initializer != nullptr)
    {
        if (!initializer->InitializeSdkRuntime())
        {
            std::cout << "Could not initialize SDK runtime" << std::endl;
            std::wcout << "Install the latest SDK runtime installer from " << initializer->LatestMidiAppSdkDownloadUrl << std::endl;
            return 1;
        }

        if (!initializer->EnsureServiceAvailable())
        {
            std::cout << "Could not demand-start the MIDI service" << std::endl;
            return 1;
        }
    }
    else
    {
        // This shouldn't happen, but good to guard
        std::cout << "Unable to create initializer" << std::endl;
        return 1;
    }

    // create the MIDI session, giving us access to Windows MIDI Services. An app may open 
    // more than one session. If so, the session name should be meaningful to the user, like
    // the name of a browser tab, or a project.

    std::cout << std::endl << "Creating session..." << std::endl;

    MidiSession session = MidiSession::Create(L"Sample Session");

    winrt::hstring endpointAId = MidiDiagnostics::DiagnosticsLoopbackAEndpointDeviceId();
    winrt::hstring endpointBId = MidiDiagnostics::DiagnosticsLoopbackBEndpointDeviceId();

    MidiEndpointConnection sendEndpoint = session.CreateEndpointConnection(endpointAId);
    std::cout << "Connected to sending endpoint: " << winrt::to_string(endpointAId) << std::endl;

    MidiEndpointConnection receiveEndpoint = session.CreateEndpointConnection(endpointBId);
    std::cout << "Connected to receiving endpoint: " << winrt::to_string(endpointBId) << std::endl;

    // Wire up an event handler to receive the message. There is a single event handler type, but the
    // MidiMessageReceivedEventArgs class provides the different ways to access the data
    // Your event handlers should return quickly as they are called synchronously.
    // 
    // Multiple connections (or more correctly, MessageReceived event sources) can share the same
    // event handler function, which does not have to be a lambda.
    auto MessageReceivedHandler = [&](IMidiMessageReceivedEventSource const& sender, MidiMessageReceivedEventArgs const& args)
        {
            // there are several ways to get the message data from the arguments. If you want to use
            // strongly-typed UMP classes, then you may start with the GetUmp() method. The GetXXX calls 
            // are all generating something within the function, so you want to call them once and then
            // keep the result around in a variable if you plan to refer to it multiple times. In 
            // contrast, the FillXXX functions will update values in provided (pre-allocated) types
            // passed in to the functions.
            IMidiUniversalPacket ump = args.GetMessagePacket();

            winrt::hstring messageSourceEndpointDeviceId{};
            // if you want to get the id of the connection which sent this, you use the sender
            MidiEndpointConnection sourceConnection = sender.as<MidiEndpointConnection>();
            if (sourceConnection != nullptr)
            {
                messageSourceEndpointDeviceId = sourceConnection.ConnectedEndpointDeviceId();
            }

            std::cout << std::endl;
            std::cout << "Received UMP" << std::endl;
            std::cout << "- Current Timestamp: " << std::dec << MidiClock::Now() << std::endl;
            std::cout << "- UMP Timestamp:     " << std::dec << ump.Timestamp() << std::endl;
            std::cout << "- UMP Msg Type:      0x" << std::hex << static_cast<uint32_t>(ump.MessageType()) << std::endl;
            std::cout << "- UMP Packet Type:   0x" << std::hex << static_cast<uint32_t>(ump.PacketType()) << std::endl;
            std::cout << "- Message:           " << winrt::to_string(MidiMessageHelper::GetMessageDisplayNameFromFirstWord(args.PeekFirstWord())) << std::endl;
            std::cout << "- Source:            " << winrt::to_string(messageSourceEndpointDeviceId) << std::endl;

            // if you wish to cast the IMidiUmp to a specific Ump Type, you can do so using .as<T> WinRT extension

            if (ump.PacketType() == MidiPacketType::UniversalMidiPacket32)
            {
                // we'll use the Ump32 type here. This is a runtimeclass that the strongly-typed 
                // 32-bit messages derive from. There are also MidiUmp64/96/128 classes.
                auto ump32 = ump.as<MidiMessage32>();

                std::cout << "- Word 0:            0x" << std::hex << ump32.Word0() << std::endl;
            }

            std::cout << std::endl;

        };

    // the returned token is used to deregister the event later.
    winrt::event_token eventRevokeToken = receiveEndpoint.MessageReceived(MessageReceivedHandler);

    std::cout << std::endl << "Opening endpoint connection" << std::endl;

    // once you have wired up all your event handlers, added any filters/listeners, etc.
    // You can open the connection. Doing this will query the cache for the in-protocol 
    // endpoint information and function blocks. If not there, it will send out the requests
    // which will come back asynchronously with responses.
    if (sendEndpoint.Open() && receiveEndpoint.Open())
    {
        std::cout << std::endl << "Creating MIDI 1.0 Channel Voice 32-bit UMP..." << std::endl;

        MidiMessage32 ump32 = MidiMessageBuilder::BuildMidi1ChannelVoiceMessage(
            MidiClock::TimestampConstantSendImmediately(),  // bypass message scheduling
            MidiGroup(5),                                   // group 6, index 5
            Midi1ChannelVoiceMessageStatus::NoteOn,         // 9
            MidiChannel(3),                                 // channel 4, index 3
            120,                                            // note 120 - hex 0x78
            100);                                           // velocity 100 hex 0x64

        // here you would set other values in the UMP word(s)

        std::cout << "Sending single UMP..." << std::endl;

        IMidiUniversalPacket ump = ump32.as<IMidiUniversalPacket>();
        MidiSendMessageResults sendResult = sendEndpoint.SendSingleMessagePacket(ump);          // could also use the SendWords methods, etc.

        if (MidiEndpointConnection::SendMessageSucceeded(sendResult))
        {
            std::cout << std::endl << " ** Wait for the sent UMP to arrive, and then press enter to cleanup. **" << std::endl;
        }
        else
        {
            std::cout << std::endl << "Message sending failed." << std::endl;
        }

        system("pause");

    }
    else
    {
        std::cout << "Unable to open one or both endpoints" << std::endl;
    }

    // Cleanup code follows =============================================================================

    // winrt::event_token has a bool operator overload to tell you if it is valid
    if (eventRevokeToken)
    {
        std::cout << std::endl << "Deregistering event handler..." << std::endl;

        // deregister the event by passing in the revoke token
        receiveEndpoint.MessageReceived(eventRevokeToken);
    }

    std::cout << "Disconnecting UMP Endpoint Connection..." << std::endl;

    // if you close the session, this automatically happens. But keeping here to show how to manually handle closing connections
    session.DisconnectEndpointConnection(sendEndpoint.ConnectionId());
    session.DisconnectEndpointConnection(receiveEndpoint.ConnectionId());

    // close the session, detaching all Windows MIDI Services resources and closing all connections
    // You can also disconnect individual Endpoint Connections when you are done with them, as we did above
    session.Close();

    // ensure we release all the WinRT and COM objects before uninitializing COM
    // otherwise, you can crash when closing down the apartment. You could just put them all in 
    // a sub-scope which closes before the uninit_apartment call, or you can set them to nullptr.
    sendEndpoint = nullptr;
    receiveEndpoint = nullptr;
    session = nullptr;

    // clean up the SDK WinRT redirection
    std::cout << "Cleaning up SDK..." << std::endl;
    if (initializer != nullptr)
    {
        initializer->ShutdownSdkRuntime();
        initializer.reset();
    }

    std::cout << "Cleaning up WinRT / COM apartment..." << std::endl;
    winrt::uninit_apartment();
}
