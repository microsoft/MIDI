// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// Further information: https://aka.ms/midi
// ============================================================================

// Windows MIDI Services sample code
// 
// Note: This sample uses all explicit types rather than "auto" so that it is 
// clear what types are being used when viewed online or in something other than
// an IDE with intellisense or equivalent. Other examples use "auto" which also
// works just fine in your own code. (the only exception in this example is the 
// event handler which remains "auto")


#include <iostream>

// files in the winrt folder have been auto-generated by C++/WinRT at compile time. If
// you need to use the versions packaged with the SDK, use the ones in /build/native/include/winmidi/winrt
#include <winrt/Windows.Foundation.h>

#include <winrt/Microsoft.Windows.Devices.Midi2.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Diagnostics.h>
#include <winrt/Microsoft.Windows.Devices.Midi2.Messages.h>

using namespace winrt::Microsoft::Windows::Devices::Midi2;                  // SDK Core
using namespace winrt::Microsoft::Windows::Devices::Midi2::Diagnostics;     // For diagnostics loopback endpoints
using namespace winrt::Microsoft::Windows::Devices::Midi2::Messages;        // For message utilities and strong types

// where you find types like IAsyncOperation, IInspectable, etc.
namespace foundation = winrt::Windows::Foundation;

// This include file has a wrapper for the bootstrapper code. You are welcome to
// use the .hpp as-is, or work the functionality into your code in whatever way
// makes the most sense for your application.
// 
// The namespace defined in the .hpp is not a WinRT namespace, just a regular C++ namespace
#include "winmidi/init/Microsoft.Windows.Devices.Midi2.Initialization.hpp"
namespace init = Microsoft::Windows::Devices::Midi2::Initialization;

// this contains the #defines for the version of the Windows MIDI Services NuGet package this app was built against
#include "winmidi/init/WindowsMidiServicesVersion.h"

int main()
{


    // initialize the thread before calling the bootstrapper or any WinRT code. You may also
    // be able to leave this out and call RoInitialize() or CoInitializeEx() before creating
    // the initializer.
    //winrt::init_apartment(winrt::apartment_type::single_threaded);

    // MTA by default
    winrt::init_apartment();

    // this is the initializer in the bootstrapper hpp file
    std::shared_ptr<init::MidiDesktopAppSdkInitializer> initializer = std::make_shared<init::MidiDesktopAppSdkInitializer>();

    // you can, of course, use guard macros instead of this check
    if (initializer != nullptr)
    {
        // Step 1: Check for presence of Windows MIDI Service
        if (!initializer->IsServiceInstalled())
        {
            // if the service is not installed, then recommend falling back to WinMM MIDI 1.0 or WinRT MIDI 1.0
            // this is the first check an app should make. Do not check Windows version information, but instead
            // always use this check to determine the presence of Windows MIDI Services.

            std::cout << "Service is not installed. This version of Windows may not be supported." << std::endl;
            return 1;
        }

        // Step 2: Attempt to initialize the SDK runtime
        if (!initializer->InitializeSdkRuntime())
        {
            // if the SDK Runtime cannot be initialized, then recommend prompting the user to download the latest SDK 
            // runtime and tools from the URL specified in the initializer. This is a manual process where the user will 
            // choose the SDK runtime from a web page that explains what they are installing. Do not circumvent user
            // consent here.
            // 
            // Recommended app action: Have a button or link the user can click to open the download page
            // in their default browser.

            std::cout << "Could not initialize SDK runtime" << std::endl;
            std::wcout << "Install the latest SDK runtime installer from " << initializer->LatestMidiAppSdkDownloadUrl << std::endl;
            return 1;
        }

        // Step 3: We were able to initialize the SDK runtime, so now check to see that the version is compatible
        if (!initializer->CheckForMinimumRequiredSdkVersion(
            WINDOWS_MIDI_SERVICES_NUGET_BUILD_VERSION_MAJOR, 
            WINDOWS_MIDI_SERVICES_NUGET_BUILD_VERSION_MINOR,
            WINDOWS_MIDI_SERVICES_NUGET_BUILD_VERSION_REVISION))
        {
            // they have a version of the SDK installed, but it is older than what this app was built against
            // so we need to inform and prompt them to download and run the latest versions of the installer
            // 
            // Recommended app action: Have a button or link the user can click to open the download page
            // in their default browser.
            std::cout << "Older version of Windows MIDI Services runtime is installed. This app requires";
            std::wcout << WINDOWS_MIDI_SERVICES_NUGET_BUILD_VERSION_FULL  << L" or higher" << std::endl;
            std::wcout << "Update to the latest SDK runtime installer from " << initializer->LatestMidiAppSdkDownloadUrl << std::endl;
            return 1;
        }

        // Step 4: Everything checks out, so start the MIDI Service if it is not already running. This
        //         kicks off enumeration / discovery / etc.
        if (!initializer->EnsureServiceAvailable())
        {
            // This is a broken installation. Fall back to other MIDI. You may want to inform the
            // user that this happened.
            std::cout << "Could not demand-start the MIDI service" << std::endl;
            return 1;
        }
    }
    else
    {
        // This shouldn't happen, but good to guard
        std::cout << "Unable to create initializer" << std::endl;
        return 1;
    }


    // Do awesome stuff with MIDI here




    // clean up the SDK WinRT redirection
    std::cout << "Cleaning up SDK..." << std::endl;
    if (initializer != nullptr)
    {
        initializer->ShutdownSdkRuntime();
        initializer.reset();
    }

    std::cout << "Cleaning up WinRT / COM apartment..." << std::endl;
    winrt::uninit_apartment();
}
